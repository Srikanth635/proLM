"""
Markdown exporter for human-readable analysis summaries
"""

from typing import Dict, Any, Optional
from pathlib import Path
from datetime import datetime

from .base_exporter import TemplateExporter
from ..models import ObjectDescription


class MarkdownExporter(TemplateExporter):
    """Exports analysis results as Markdown documents"""

    def __init__(self, output_dir: Path):
        super().__init__(output_dir, "md")
        self._setup_templates()

    def _setup_templates(self):
        """Setup Markdown templates"""
        self.templates["summary_report"] = self._get_summary_template()
        self.templates["detailed_report"] = self._get_detailed_template()

    async def export(self,
                     object_description: ObjectDescription,
                     knowledge_graph_turtle: Optional[str] = None,
                     metadata: Dict[str, Any] = None) -> str:
        """Export object description as Markdown summary"""

        # Prepare context
        context = self._prepare_context(object_description, knowledge_graph_turtle, metadata)
        context.update({
            'object': object_description,
            'has_kg': knowledge_graph_turtle is not None,
            'kg_preview': self._get_kg_preview(knowledge_graph_turtle) if knowledge_graph_turtle else None
        })

        # Generate dynamic sections
        context.update(self._generate_markdown_sections(object_description))

        # Render Markdown content
        markdown_content = self._render_template("summary_report", context)

        # Generate filename
        safe_name = "".join(c for c in object_description.name if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_name = safe_name.replace(' ', '_').lower()
        filename = self._generate_filename(f"summary_{safe_name}", "md", timestamp=False)

        # Write to file
        return self._write_file(markdown_content, filename)

    def _get_summary_template(self) -> str:
        """Markdown summary template"""
        return """# üîç SOMA Object Analysis Summary

## {object.name}

**Description:** {object.description}  
**Confidence:** {object.confidence_score:.1%}  
**Analysis Date:** {export_date}

---

## üìä Quick Overview

| Property | Value |
|----------|--------|
| **Category** | {object.semantic.category.value} |
| **Primary Color** | {object.visual.colors.primary_color} |
| **Shape** | {object.geometric.shape.primary_shape.value} |
| **Material** | {object.material.primary_material.value} |
{mass_row}
{graspability_row}

---

## üé® Visual Properties

{visual_details}

---

## üìê Geometric Properties

{geometric_details}

---

## üß± Material Properties

{material_details}

---

## ‚ö° Capabilities & Affordances

### Functional Capabilities
{functional_capabilities}

### Task Affordances
{task_affordances}

---

## üè∑Ô∏è Semantic Information

### Classification
- **Primary Category:** {object.semantic.category.value}
{subcategories_section}

### Context
{semantic_context}

---

{knowledge_graph_section}

## üîß Technical Details

{technical_details}

---

*Generated by SOMA Object Analysis System v0.1.0*  
*Timestamp: {timestamp}*
"""

    def _get_detailed_template(self) -> str:
        """Detailed Markdown template"""
        return """# üîç Detailed SOMA Object Analysis

## {object.name}

> {object.description}

**Analysis Confidence:** {object.confidence_score:.2%}  
**Generated:** {export_date}  
**Source:** {object.source}

---

## Table of Contents

1. [Visual Analysis](#visual-analysis)
2. [Geometric Analysis](#geometric-analysis)  
3. [Material Analysis](#material-analysis)
4. [Capability Analysis](#capability-analysis)
5. [Semantic Analysis](#semantic-analysis)
6. [Knowledge Graph](#knowledge-graph)
7. [Technical Metadata](#technical-metadata)

---

## Visual Analysis

{detailed_visual}

## Geometric Analysis

{detailed_geometric}

## Material Analysis

{detailed_material}

## Capability Analysis

{detailed_capabilities}

## Semantic Analysis

{detailed_semantic}

{detailed_kg_section}

## Technical Metadata

{detailed_metadata}

---

*End of detailed analysis report*
"""

    def _generate_markdown_sections(self, obj: ObjectDescription) -> Dict[str, str]:
        """Generate dynamic Markdown sections"""
        sections = {}

        # Mass row for quick overview table
        if obj.material.mass:
            sections['mass_row'] = f"| **Mass** | {obj.material.mass} kg |"
        else:
            sections['mass_row'] = ""

        # Graspability row
        graspability = obj.capabilities.functional_affordances.graspability
        if graspability is not None:
            sections['graspability_row'] = f"| **Graspability** | {graspability:.2f}/1.0 |"
        else:
            sections['graspability_row'] = ""

        # Visual details
        visual_parts = [f"- **Primary Color:** {obj.visual.colors.primary_color}"]

        if obj.visual.colors.rgb:
            rgb = obj.visual.colors.rgb
            visual_parts.append(f"- **RGB Values:** R:{rgb.r}, G:{rgb.g}, B:{rgb.b}")

        if obj.visual.colors.secondary_colors:
            colors_list = ", ".join(obj.visual.colors.secondary_colors)
            visual_parts.append(f"- **Secondary Colors:** {colors_list}")

        visual_parts.append(f"- **Surface Texture:** {obj.visual.surface.texture.value}")

        if obj.visual.surface.finish:
            visual_parts.append(f"- **Surface Finish:** {obj.visual.surface.finish}")

        sections['visual_details'] = "\n".join(visual_parts)

        # Geometric details
        geometric_parts = [f"- **Primary Shape:** {obj.geometric.shape.primary_shape.value}"]

        dims = obj.geometric.shape.dimensions
        dim_parts = []
        if dims.width: dim_parts.append(f"Width: {dims.width}m")
        if dims.height: dim_parts.append(f"Height: {dims.height}m")
        if dims.depth: dim_parts.append(f"Depth: {dims.depth}m")
        if dims.radius: dim_parts.append(f"Radius: {dims.radius}m")
        if dims.length: dim_parts.append(f"Length: {dims.length}m")

        if dim_parts:
            geometric_parts.append(f"- **Dimensions:** {', '.join(dim_parts)}")

        volume = dims.volume()
        if volume:
            geometric_parts.append(f"- **Estimated Volume:** {volume:.6f} m¬≥")

        sections['geometric_details'] = "\n".join(geometric_parts)

        # Material details
        material_parts = [f"- **Primary Material:** {obj.material.primary_material.value}"]

        if obj.material.secondary_materials:
            sec_materials = ", ".join([m.value for m in obj.material.secondary_materials])
            material_parts.append(f"- **Secondary Materials:** {sec_materials}")

        if obj.material.mass:
            material_parts.append(f"- **Mass:** {obj.material.mass} kg")

        if obj.material.density:
            material_parts.append(f"- **Density:** {obj.material.density} kg/m¬≥")

        if obj.material.temperature is not None:
            material_parts.append(f"- **Temperature:** {obj.material.temperature}¬∞C")

        sections['material_details'] = "\n".join(material_parts)

        # Functional capabilities
        caps = obj.capabilities.functional_affordances
        func_caps = []

        capabilities_list = [
            ("can_cut", "Cutting"),
            ("can_contain", "Containment"),
            ("can_grasp", "Graspable"),
            ("can_support", "Supporting"),
            ("can_pour", "Pouring")
        ]

        for attr, name in capabilities_list:
            value = getattr(caps, attr)
            if value is not None:
                status = "‚úÖ Yes" if value else "‚ùå No"
                func_caps.append(f"- **{name}:** {status}")

        if caps.graspability is not None:
            func_caps.append(f"- **Graspability Score:** {caps.graspability:.2f}/1.0")

        sections['functional_capabilities'] = "\n".join(
            func_caps) if func_caps else "- No specific functional capabilities identified"

        # Task affordances
        task_parts = []

        if obj.capabilities.task_affordances.primary_tasks:
            tasks = ", ".join(obj.capabilities.task_affordances.primary_tasks)
            task_parts.append(f"- **Primary Tasks:** {tasks}")

        if obj.capabilities.task_affordances.secondary_tasks:
            sec_tasks = ", ".join(obj.capabilities.task_affordances.secondary_tasks)
            task_parts.append(f"- **Secondary Tasks:** {sec_tasks}")

        if obj.capabilities.task_affordances.requires_tools:
            tools = ", ".join(obj.capabilities.task_affordances.requires_tools)
            task_parts.append(f"- **Required Tools:** {tools}")

        sections['task_affordances'] = "\n".join(task_parts) if task_parts else "- No specific tasks identified"

        # Subcategories section
        if obj.semantic.subcategories:
            subcats = ", ".join(obj.semantic.subcategories)
            sections['subcategories_section'] = f"- **Subcategories:** {subcats}"
        else:
            sections['subcategories_section'] = ""

        # Semantic context
        context_parts = []

        if obj.semantic.typical_locations:
            locations = ", ".join(obj.semantic.typical_locations)
            context_parts.append(f"- **Typical Locations:** {locations}")

        if obj.semantic.associated_activities:
            activities = ", ".join(obj.semantic.associated_activities)
            context_parts.append(f"- **Associated Activities:** {activities}")

        if obj.semantic.context.cultural_significance:
            context_parts.append(f"- **Cultural Significance:** {obj.semantic.context.cultural_significance}")

        if obj.semantic.context.safety_considerations:
            safety = ", ".join(obj.semantic.context.safety_considerations)
            context_parts.append(f"- **Safety Considerations:** {safety}")

        sections['semantic_context'] = "\n".join(
            context_parts) if context_parts else "- No specific contextual information available"

        # Knowledge graph section
        if sections.get('has_kg'):
            sections['knowledge_graph_section'] = """## üß† Knowledge Graph

This object has been represented as a SOMA-aligned knowledge graph containing:

- **Object Instance:** Primary object with all properties
- **Quality Regions:** Color, shape, and material properties  
- **Affordances:** Capability and task relationships
- **Spatial Relations:** Position and support relationships

```turtle
# Sample from generated knowledge graph:
{kg_preview}
```

> **Note:** Complete knowledge graph available in `knowledge_graph.ttl`

"""
        else:
            sections['knowledge_graph_section'] = ""

        # Technical details
        tech_parts = [
            f"- **Analysis Source:** {obj.source}",
            f"- **Confidence Score:** {obj.confidence_score:.3f}",
            f"- **Object State Integrity:** {obj.state.integrity:.1%}",
            f"- **Cleanliness:** {obj.state.cleanliness.value}"
        ]

        if obj.state.functional_state:
            tech_parts.append(f"- **Functional State:** {obj.state.functional_state}")

        sections['technical_details'] = "\n".join(tech_parts)

        return sections

    def _get_kg_preview(self, kg_turtle: Optional[str]) -> str:
        """Get a preview of the knowledge graph"""
        if not kg_turtle:
            return "No knowledge graph available"

        lines = kg_turtle.split('\n')
        # Get first 10 non-empty, non-prefix lines
        content_lines = [line for line in lines if line.strip() and not line.startswith('@prefix')]
        preview_lines = content_lines[:5]  # Show first 5 triples

        preview = "\n".join(preview_lines)
        if len(content_lines) > 5:
            preview += f"\n... and {len(content_lines) - 5} more triples"

        return preview

    def _render_template(self, template_name: str, context: Dict[str, Any]) -> str:
        """Render template with context"""
        template = self._load_template(template_name)

        try:
            return template.format(**context)
        except KeyError as e:
            self.logger.error(f"Missing template variable: {e}")
            # Return template with placeholder for missing variable
            return template.replace(f"{{{e.args[0]}}}", f"[MISSING: {e.args[0]}]")


class DetailedMarkdownExporter(MarkdownExporter):
    """Exports detailed analysis reports in Markdown"""

    async def export(self,
                     object_description: ObjectDescription,
                     knowledge_graph_turtle: Optional[str] = None,
                     metadata: Dict[str, Any] = None) -> str:
        """Export detailed object description as Markdown"""

        # Use detailed template instead of summary
        context = self._prepare_context(object_description, knowledge_graph_turtle, metadata)
        context.update({
            'object': object_description,
            'has_kg': knowledge_graph_turtle is not None,
            'kg_preview': self._get_kg_preview(knowledge_graph_turtle) if knowledge_graph_turtle else None
        })

        # Generate detailed sections
        context.update(self._generate_detailed_sections(object_description, metadata))

        # Render detailed template
        markdown_content = self._render_template("detailed_report", context)

        # Generate filename
        safe_name = "".join(c for c in object_description.name if c.isalnum() or c in (' ', '-', '_')).strip()
        safe_name = safe_name.replace(' ', '_').lower()
        filename = self._generate_filename(f"detailed_analysis_{safe_name}", "md", timestamp=False)

        return self._write_file(markdown_content, filename)

    def _generate_detailed_sections(self, obj: ObjectDescription, metadata: Dict[str, Any]) -> Dict[str, str]:
        """Generate detailed sections for comprehensive report"""
        sections = {}

        # Detailed visual analysis
        sections['detailed_visual'] = f"""
### Color Analysis
- **Primary Color:** {obj.visual.colors.primary_color}
{f"- **RGB Values:** {obj.visual.colors.rgb.r}, {obj.visual.colors.rgb.g}, {obj.visual.colors.rgb.b}" if obj.visual.colors.rgb else ""}
{f"- **HSV Values:** H:{obj.visual.colors.hsv.h:.1f}¬∞, S:{obj.visual.colors.hsv.s:.1f}%, V:{obj.visual.colors.hsv.v:.1f}%" if obj.visual.colors.hsv else ""}
{f"- **Secondary Colors:** {', '.join(obj.visual.colors.secondary_colors)}" if obj.visual.colors.secondary_colors else ""}

### Surface Properties
- **Texture:** {obj.visual.surface.texture.value}
{f"- **Finish:** {obj.visual.surface.finish}" if obj.visual.surface.finish else ""}
{f"- **Transparency:** {obj.visual.surface.transparency:.2f}" if obj.visual.surface.transparency else ""}
{f"- **Reflectivity:** {obj.visual.surface.reflectivity:.2f}" if obj.visual.surface.reflectivity else ""}
"""

        # Add other detailed sections...
        sections['detailed_geometric'] = "### Shape and Dimensions\n[Detailed geometric analysis]"
        sections['detailed_material'] = "### Material Composition\n[Detailed material analysis]"
        sections['detailed_capabilities'] = "### Capability Assessment\n[Detailed capability analysis]"
        sections['detailed_semantic'] = "### Semantic Classification\n[Detailed semantic analysis]"
        sections[
            'detailed_kg_section'] = "## Knowledge Graph Representation\n[Detailed KG information]" if sections.get(
            'has_kg') else ""
        sections[
            'detailed_metadata'] = f"### System Information\n- **Analysis Metadata:** {metadata}" if metadata else "### System Information\n- No additional metadata available"

        return sections